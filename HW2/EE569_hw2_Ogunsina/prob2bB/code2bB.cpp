//  EE569 Homework Assignment # 2 Prob 2b, A : Error Diff, JJN//  Name:   Morayo Abisola Ogunsina//  ID:     7371213793//  Date:   02/23/2021//  email:  ogunsina@usc.edu // To run the code : // 1. Use terminal and navigate to code path = /prob2bB // 2. type in g++ -o prob2bB code2bB.cpp // 3. then prob2bB.exe <input_raw>  // e.g prob2bB.exe bridge.raw  // to view output on ImageJ: // 1. import raw output file // 2. select image type 8-bit RGB // 3. set width to 332, height to 501 // 4. OK.#include <string.h>#include <stdio.h>#include <iostream>#include <stdlib.h>using namespace std; /* Write Raw funtion: writes the processed image data, saves into a .raw file for viewing*/void writeRaw(void* outputdata, const int length, const char* filename) {	FILE* file;	// Write image data (filename specified by second argument) from image data matrix	if (!(file = fopen(filename, "wb"))) {		cout << "Cannot open file: " << filename << endl;		exit(1);	}	fwrite(outputdata, sizeof(unsigned char), length, file); // mult by 3 for rgb color	fclose(file);}int main(int argc, char* argv[]){	///////////////////////// BEGINNING CODE PROVIDED BY TA, ADDED MODIFICATIONS /////////////////////////	// Define file pointer and variables	FILE* file;	//---------------------------------Get aruguments------------------------------------------   	const int ImgWidth = 332;   // number of columns in the image,	const int ImgHeight = 501;  // number of rows in the image	const int SIZE = ImgHeight * ImgWidth;  	//----------------variables	unsigned char Imagedata [ImgHeight][ImgWidth];     // input image	//--------------------- Error Diffused ArrayOutput -------------------------	unsigned char OutputJJN[ImgHeight][ImgWidth];		//--------------------for storing the imagefile names----------------------------------//	const char* FSfile = "I2Img.raw";		//--------------------------read image----------------------------	if (!(file = fopen(argv[1], "rb"))) {		cout << "Cannot open file: " << argv[1] << endl;		exit(1);	}	fread(Imagedata, sizeof(unsigned char), SIZE, file);	fclose(file);	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////	double ImageDataTemp[ImgHeight][ImgWidth];			        // normalize first			// will need this to add the error values to the image			// method suggested by Dr. Kuo.			// diffuse the error into the imagedata matrix			for (int i = 0; i < ImgHeight; i++)	{		for (int j = 0; j < ImgWidth; j++)		{			ImageDataTemp[i][j] = 1 - (float)Imagedata[i][j] / 255;		}	}	//-------------------- apply the Jarvis, Judice and Ninke error diffusion matrix---------------------//	//                     for digital half-toning	/*                     5x5 matrix: I5/48						   0 0 0 0 0						   0 0 0 0 0						   0 0 0 7 5						   3 5 7 5 3						   1 3 5 3 1	*/	double tempError = 0; 	for (int h = 0; h < ImgHeight; h++) {		// do left to right scanning aka even indexed-scanning		if (h % 2==0) {			for (int w = 0; w < ImgWidth; w++) {				if (ImageDataTemp[h][w] <= 0.5)				{					// now get the difference to get the error					tempError = ImageDataTemp[h][w] - 0;					OutputJJN[h][w] = (unsigned char)255;				}				else				{					// now get the difference to get the error					tempError = ImageDataTemp[h][w] - 1;					OutputJJN[h][w] = (unsigned char)0;				}	//--------------- use the index location of the non-zero numbers--------------------//				if (w + 1 < ImgWidth)					ImageDataTemp[h][w + 1] += tempError * 7 / 48;				if (h + 1 < ImgHeight)					ImageDataTemp[h + 1][w] += tempError * 7 / 48;								if (w + 1 < ImgWidth && h + 1 < ImgHeight)					ImageDataTemp[h + 1][w + 1] += tempError * 5 / 48;				if (w + 2 < ImgWidth)					ImageDataTemp[h][w + 2] += tempError * 5 / 48;								if (h + 2 < ImgHeight)					ImageDataTemp[h + 2][w] += tempError * 5 / 48;				if (w > 0 && h + 1 < ImgHeight)					ImageDataTemp[h + 1][w - 1] += tempError * 5 / 48;				if (w + 1 < ImgWidth && h + 2 < ImgHeight)					ImageDataTemp[h + 2][w + 1] += tempError * 3 / 48;								if (w + 2 < ImgWidth && h + 1 < ImgHeight)					ImageDataTemp[h + 1][w + 2] += tempError * 3 / 48;				if (w > 0 && h + 2 < ImgHeight)					ImageDataTemp[h + 2][w - 1] += tempError * 3 / 48;				if (w - 1 > 0 && h + 1 < ImgHeight)					ImageDataTemp[h + 1][w - 2] += tempError * 3 / 48;				if (w + 2 < ImgWidth && h + 2 < ImgHeight)					ImageDataTemp[h + 2][w + 2] += tempError * 1 / 48;				if (w - 1 > 0 && h + 2 < ImgHeight)					ImageDataTemp[h + 2][w - 2] += tempError * 1 / 48;			}		}		// do right to left scanning aka odd indexed-scanning		if (h % 2 != 0) {			for (int w = ImgWidth - 1; w >= 0; w--) {				if (ImageDataTemp[h][w] <= 0.5)				{					// now get the difference to get the error					tempError = ImageDataTemp[h][w] - 0; 					OutputJJN[h][w] = (unsigned char)255;				}				else				{					// now get the difference to get the error					tempError = ImageDataTemp[h][w] - 1;					OutputJJN[h][w] = (unsigned char)0;				}				//--------------- use the index location of the non-zero numbers--------------------//				if (w + 1 < ImgWidth)					ImageDataTemp[h][w + 1] += tempError * 7 / 48;				if (h + 1 < ImgHeight)					ImageDataTemp[h + 1][w] += tempError * 7 / 48;				if (w + 1 < ImgWidth && h + 1 < ImgHeight)					ImageDataTemp[h + 1][w + 1] += tempError * 5 / 48;				if (w + 2 < ImgWidth)					ImageDataTemp[h][w + 2] += tempError * 5 / 48;				if (h + 2 < ImgHeight)					ImageDataTemp[h + 2][w] += tempError * 5 / 48;				if (w > 0 && h + 1 < ImgHeight)					ImageDataTemp[h + 1][w - 1] += tempError * 5 / 48;				if (w + 1 < ImgWidth && h + 2 < ImgHeight)					ImageDataTemp[h + 2][w + 1] += tempError * 3 / 48;				if (w + 2 < ImgWidth && h + 1 < ImgHeight)					ImageDataTemp[h + 1][w + 2] += tempError * 3 / 48;				if (w > 0 && h + 2 < ImgHeight)					ImageDataTemp[h + 2][w - 1] += tempError * 3 / 48;				if (w - 1 > 0 && h + 1 < ImgHeight)					ImageDataTemp[h + 1][w - 2] += tempError * 3 / 48;				if (w + 2 < ImgWidth && h + 2 < ImgHeight)					ImageDataTemp[h + 2][w + 2] += tempError * 1 / 48;				if (w - 1 > 0 && h + 2 < ImgHeight)					ImageDataTemp[h + 2][w - 2] += tempError * 1 / 48;			}		}	}	//--------------------------save Dithered image to File--------------------------------------	writeRaw(OutputJJN, ImgHeight* ImgWidth * 1, FSfile);	return 0;}