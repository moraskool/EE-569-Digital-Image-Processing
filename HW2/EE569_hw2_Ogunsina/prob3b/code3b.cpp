//  EE569 Homework Assignment # 2 Prob 3b :  : MBVQ Error Diff for Color Images //  Date:   02/23/2021//  Name:   Morayo Abisola Ogunsina//  ID:     7371213793//  email:  ogunsina@usc.edu // To run the code : // 1. Use terminal and navigate to code path = /prob3b // 2. type in g++ -o prob3b code3b.cpp // 3. then prob3b.exe <input_raw> // e.g prob3b.exe fish.raw  // to view output on ImageJ: // 1. import raw output file // 2. select image type 24-bit RGB // 3. set width to 640, height to 426 // 4. OK.#include <string.h>#include <stdio.h>#include <iostream>#include <stdlib.h>using namespace std;/** % getNearestVertex: find nearst vertex in the given MBVQ for a target pixel%% INPUT:% mbvq (char array): the mbvq the target pixel is related to% R, G, B (range:0~1): the R, G, B channel value of the target pixel%% OUPUT:% vertex (char array): the name of the closest vertex%% Ref: "Color Diffusion: Error-Diffusion for Color Halftones% by Shaked, Arad, Fitzhugh, and Sobel -- HP Labs% Hewlett-Packard Laboratories TR 96-128% and Electronic Imaging, Proc. SPIE 3648, 1999% Adapted from Halftoning Toolbox Version 1.2 released July 2005 (Univ. of Texas)*/int CMYW(string mbvq, float R, float G, float B) {		int vertex;	if (mbvq == "CMYW") {		//White		vertex = 1;		if (B < 128) {			if (B <= R) {				if (B <= G) {					//Yellow					vertex = 7;				}			}		}		if (G < 128) {			if (G <= B) {				if (G <= R) {					//Magenta					vertex = 6;				}			}		}		if (R < 128) {			if (R <= B) {				if (R <= G) {					//Cyan					vertex = 5;				}			}		}	}	return vertex;}int MYGC(string mbvq, float R, float G, float B) {	int vertex;		if (mbvq == "MYGC") {		//Magenta		vertex = 6;		if (G >= B) {			if (R >= B) {				if (R >= 128) {					//Yellow					vertex = 7;				}				else {					//Green					vertex = 3;				}			}		}		if (G >= R) {			if (B >= R) {				if (B >= 128) {					//Cyan					vertex = 5;				}				else {					//Green					vertex = 3;				}			}		}	}	return vertex;}int RGMY(string mbvq, float R, float G, float B) {	int vertex;	if (mbvq == "RGMY") {		if (B > 128) {			if (R > 128) {				if (B >= G) {										vertex = 6; //Magenta				}				else {										vertex = 7; //Yellow				}			}			else {				if (G > B + R) {										vertex = 3; //Green				}				else {										vertex = 6; //Magenta				}			}		}		else {			if (R >= 128) {				if (G >= 128) {										vertex = 7; //Yellow				}				else {										vertex = 2; //Red				}			}			else {				if (R >= G) {										vertex = 2; //Red				}				else {										vertex = 3; //Green				}			}		}	}	return vertex;}int KRGB(string mbvq, float R, float G, float B) {		int vertex;	if (mbvq == "KRGB") {				vertex = 8; //Black		if (B > 128) {			if (B >= R) {				if (B >= G) {										vertex = 4; //Blue				}			}		}		if (G > 128) {			if (G >= B) {				if (G >= R) {										vertex = 3; //Green				}			}		}		if (R > 128) {			if (R >= B) {				if (R >= G) {										vertex = 2; //Red				}			}		}	}	return vertex;}int RGBM(string mbvq, float R, float G, float B) {		int vertex;	if (mbvq == "RGBM") {				vertex = 3; //Green		if (R > G) {			if (R >= B) {				if (B < 128) {										vertex = 2; //Red				}				else {										vertex = 6; //Magenta				}			}		}		if (B > G) {			if (B >= R) {				if (R < 128) {										vertex = 4; //Blue				}				else {										vertex = 6; //Magenta				}			}		}	}	return vertex;}int CMGB(string mbvq, float R, float G, float B) {	int vertex;	if (mbvq == "CMGB") {		if (B > 128) {			if (R > 128) {				if (G >= R) {										vertex = 5; //Cyan				}				else {										vertex = 6; //Magenta				}			}			else {				if (G > 128) {										vertex = 5; //Cyan				}				else {										vertex = 4; //Blue				}			}		}		else {			if (R > 128) {				if (R - G + B >= 128) {										vertex = 6; //Magenta				}				else {										vertex = 3; //Green				}			}			else {				if (G >= B) {										vertex = 3; //Green				}				else {										vertex = 4; //Blue				}			}		}	}	return vertex;}int getMBVQ(float R, float G, float B) {	if ((R + G) > 255) {		if ((G + B) > 255) {			if ((R + G + B) > 510) {				return 1;			}			else {				return 2;  //Red			}		}		else {			return 3; //Green		}	}	else {		if (!((G + B) > 255)) {			if (!((R + G + B) > 255)) {				return 4; //Blue			}			else {				return 5;//cyan			}		}		else { 			return 6; //Magenta		}	}}/* Write Raw funtion: writes the processed image data, saves into a .raw file for viewing*/void writeRaw(void* outputdata, const int length, const char* filename) {	FILE* file;	// Write image data (filename specified by second argument) from image data matrix	if (!(file = fopen(filename, "wb"))) {		cout << "Cannot open file: " << filename << endl;		exit(1);	}	fwrite(outputdata, sizeof(unsigned char), length, file); // mult by 3 for rgb color	fclose(file);}int main(int argc, char* argv[]){	///////////////////////// BEGINNING CODE PROVIDED BY TA, ADDED MODIFICATIONS /////////////////////////	// Define file pointer and variables	FILE* file;	const int ImgWidth = 640;    // number of columns in the 	const int ImgHeight = 426;	 // number of hs in the image	const int BytesPerPixel = 3; // color type 1, grayscale, 3 RGB	const int SIZE = ImgHeight * ImgWidth * BytesPerPixel;	//----------------variables	unsigned char Imagedata[ImgHeight][ImgWidth][BytesPerPixel];  // input image	unsigned char OutputMBVQ[ImgHeight][ImgWidth][3];             // for the output array, in color	//--------------------------read image----------------------------	if (!(file = fopen(argv[1], "rb"))) {		cout << "Cannot open file: " << argv[1] << endl;		exit(1);	}	// read the House.raw and store in 1d array	fread(Imagedata, sizeof(unsigned char), SIZE, file);	fclose(file);	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////	///////////////////////// MEMORY ALLOCATION FOR VARIABLES /////////////////////////		//--------------------- temp memory to normalize the CMY color channels-------------------------	float ImageError[ImgHeight][ImgWidth][3];	for (int h = 0; h < ImgHeight; h++) {		for (int col = 0; col < ImgWidth; col++) {			ImageError[h][col][0] = (float)Imagedata[h][col][0];			ImageError[h][col][1] = (float)Imagedata[h][col][1];			ImageError[h][col][2] = (float)Imagedata[h][col][2];		}	}	//-------------------- apply the Floyd-Steinberg error diffusion matrix---------------------//	//                     for digital half-toning for each color channel	/*                     3 x 3 matrix: I3/16						   0 0 0						   0 0 7						   3 5 1	*/	/*		CMYQW = 1, MYGC = 2, RGMY = 3, KRGB = 4, RGBM = 5, CMGB = 6	 */	const char* colour[6] = { "CMYW", "MYGC", "RGMY",  "KRGB", "RGBM" , "CMGB" };	for (unsigned int h = 0; h < ImgHeight; h++) {		// do left to right scanning aka even indexed-scanning		if (h % 2 == 0) {			for (unsigned int w = 0; w < ImgWidth; w++) {				float R = ImageError[h][w][0];				float G = ImageError[h][w][1];				float B = ImageError[h][w][2];				// get the 6 MBVQ values in the CMYK space				int mbvq = getMBVQ(R, G, B);				int vertex;				switch (mbvq) {				case 1: vertex = CMYW(colour[0], R, G, B);					break;				case 2: vertex = MYGC(colour[1], R, G, B);					break;				case 3: vertex = RGMY(colour[2], R, G, B);					break;				case 4: vertex = KRGB(colour[3], R, G, B);					break;				case 5: vertex = RGBM(colour[4], R, G, B);					break;				case 6: vertex = CMGB(colour[5], R, G, B);					break;				}				switch (vertex) {				case 1:					OutputMBVQ[h][w][0] = 255;					OutputMBVQ[h][w][1] = 255;					OutputMBVQ[h][w][2] = 255;					break;				case 2:					OutputMBVQ[h][w][0] = 255;					OutputMBVQ[h][w][1] = 0;					OutputMBVQ[h][w][2] = 0;					break;				case 3:					OutputMBVQ[h][w][0] = 0;					OutputMBVQ[h][w][1] = 255;					OutputMBVQ[h][w][2] = 0;					break;				case 4:					OutputMBVQ[h][w][0] = 0;					OutputMBVQ[h][w][1] = 0;					OutputMBVQ[h][w][2] = 255;					break;				case 5:					OutputMBVQ[h][w][0] = 0;					OutputMBVQ[h][w][1] = 255;					OutputMBVQ[h][w][2] = 255;					break;				case 6:					OutputMBVQ[h][w][0] = 255;					OutputMBVQ[h][w][1] = 0;					OutputMBVQ[h][w][2] = 255;					break;				case 7:					OutputMBVQ[h][w][0] = 255;					OutputMBVQ[h][w][1] = 255;					OutputMBVQ[h][w][2] = 0;					break;				case 8:					OutputMBVQ[h][w][0] = 0;					OutputMBVQ[h][w][1] = 0;					OutputMBVQ[h][w][2] = 0;					break;				}				// error variables				float tempError0 = ImageError[h][w][0] - OutputMBVQ[h][w][0];				float tempError1 = ImageError[h][w][1] - OutputMBVQ[h][w][1];				float tempError2 = ImageError[h][w][2] - OutputMBVQ[h][w][2];				if (w == 0) {					ImageError[h][w + 1][0] += tempError0 * (7 / 16.0);					ImageError[h][w + 1][1] += tempError1 * (7 / 16.0);					ImageError[h][w + 1][2] += tempError2 * (7 / 16.0);					ImageError[h + 1][w][0] += tempError0 * (5 / 16.0);					ImageError[h + 1][w][1] += tempError1 * (5 / 16.0);					ImageError[h + 1][w][2] += tempError2 * (5 / 16.0);					ImageError[h + 1][w + 1][0] += tempError0 * (1 / 16.0);					ImageError[h + 1][w + 1][1] += tempError1 * (1 / 16.0);					ImageError[h + 1][w + 1][2] += tempError2 * (1 / 16.0);				}				else if (w == ImgWidth - 1) {					ImageError[h + 1][w][0] += tempError0 * (5 / 16.0);					ImageError[h + 1][w][1] += tempError1 * (5 / 16.0);					ImageError[h + 1][w][2] += tempError2 * (5 / 16.0);					ImageError[h + 1][w - 1][0] += tempError0 * (3 / 16.0);					ImageError[h + 1][w - 1][1] += tempError1 * (3 / 16.0);					ImageError[h + 1][w - 1][2] += tempError2 * (3 / 16.0);				}				else if (h == ImgHeight - 1) {					ImageError[h][w + 1][0] += tempError0 * (7 / 16.0);					ImageError[h][w + 1][1] += tempError1 * (7 / 16.0);					ImageError[h][w + 1][2] += tempError2 * (7 / 16.0);				}				else {					ImageError[h][w + 1][0] += tempError0 * (7 / 16.0);					ImageError[h][w + 1][1] += tempError1 * (7 / 16.0);					ImageError[h][w + 1][2] += tempError2 * (7 / 16.0);					ImageError[h + 1][w][0] += tempError0 * (5 / 16.0);					ImageError[h + 1][w][1] += tempError1 * (5 / 16.0);					ImageError[h + 1][w][2] += tempError2 * (5 / 16.0);					ImageError[h + 1][w - 1][0] += tempError0 * (3 / 16.0);					ImageError[h + 1][w - 1][1] += tempError1 * (3 / 16.0);					ImageError[h + 1][w - 1][2] += tempError2 * (3 / 16.0);					ImageError[h + 1][w + 1][0] += tempError0 * (1 / 16.0);					ImageError[h + 1][w + 1][1] += tempError1 * (1 / 16.0);					ImageError[h + 1][w + 1][2] += tempError2 * (1 / 16.0);				}			}		}		// do right to left scanning aka odd indexed-scanning		if (h % 2 != 0) {			for (unsigned int w = 0; w < ImgWidth; w++) {				float R = ImageError[h][w][0];				float G = ImageError[h][w][1];				float B = ImageError[h][w][2];				int mbvq = getMBVQ(R, G, B);				int vertexValue;				switch (mbvq) {				case 1: vertexValue = CMYW(colour[0], R, G, B);					break;				case 2: vertexValue = MYGC(colour[1], R, G, B);					break;				case 3: vertexValue = RGMY(colour[2], R, G, B);					break;				case 4: vertexValue = KRGB(colour[3], R, G, B);					break;				case 5: vertexValue = RGBM(colour[4], R, G, B);					break;				case 6: vertexValue = CMGB(colour[5], R, G, B);					break;				}				switch (vertexValue) {				case 1:					OutputMBVQ[h][w][0] = 255;					OutputMBVQ[h][w][1] = 255;					OutputMBVQ[h][w][2] = 255;					break;				case 2:					OutputMBVQ[h][w][0] = 255;					OutputMBVQ[h][w][1] = 0;					OutputMBVQ[h][w][2] = 0;					break;				case 3:					OutputMBVQ[h][w][0] = 0;					OutputMBVQ[h][w][1] = 255;					OutputMBVQ[h][w][2] = 0;					break;				case 4:					OutputMBVQ[h][w][0] = 0;					OutputMBVQ[h][w][1] = 0;					OutputMBVQ[h][w][2] = 255;					break;				case 5:					OutputMBVQ[h][w][0] = 0;					OutputMBVQ[h][w][1] = 255;					OutputMBVQ[h][w][2] = 255;					break;				case 6:					OutputMBVQ[h][w][0] = 255;					OutputMBVQ[h][w][1] = 0;					OutputMBVQ[h][w][2] = 255;					break;				case 7:					OutputMBVQ[h][w][0] = 255;					OutputMBVQ[h][w][1] = 255;					OutputMBVQ[h][w][2] = 0;					break;				case 8:					OutputMBVQ[h][w][0] = 0;					OutputMBVQ[h][w][1] = 0;					OutputMBVQ[h][w][2] = 0;					break;				}				// error variables				float tempError0 = ImageError[h][w][0] - OutputMBVQ[h][w][0];				float tempError1 = ImageError[h][w][1] - OutputMBVQ[h][w][1];				float tempError2 = ImageError[h][w][2] - OutputMBVQ[h][w][2];				if (w == 0) {					ImageError[h + 1][w][0] += tempError0 * (5 / 16.0);					ImageError[h + 1][w][1] += tempError1 * (5 / 16.0);					ImageError[h + 1][w][2] += tempError2 * (5 / 16.0);					ImageError[h + 1][w + 1][0] += tempError0 * (3 / 16.0);					ImageError[h + 1][w + 1][1] += tempError1 * (3 / 16.0);					ImageError[h + 1][w + 1][2] += tempError2 * (3 / 16.0);				}				else if (w == ImgWidth - 1) {					ImageError[h][w - 1][0] += tempError0 * (7 / 16.0);					ImageError[h][w - 1][1] += tempError1 * (7 / 16.0);					ImageError[h][w - 1][2] += tempError2 * (7 / 16.0);					ImageError[h + 1][w][0] += tempError0 * (5 / 16.0);					ImageError[h + 1][w][1] += tempError1 * (5 / 16.0);					ImageError[h + 1][w][2] += tempError2 * (5 / 16.0);					ImageError[h + 1][w - 1][0] += tempError0 * (1 / 16.0);					ImageError[h + 1][w - 1][1] += tempError1 * (1 / 16.0);					ImageError[h + 1][w - 1][2] += tempError2 * (1 / 16.0);				}				else if (h == ImgHeight - 1) {					ImageError[h][w - 1][0] += tempError0 * (7 / 16.0);					ImageError[h][w - 1][1] += tempError1 * (7 / 16.0);					ImageError[h][w - 1][2] += tempError2 * (7 / 16.0);				}				else {					ImageError[h][w - 1][0] += tempError0 * (7 / 16.0);					ImageError[h][w - 1][1] += tempError1 * (7 / 16.0);					ImageError[h][w - 1][2] += tempError2 * (7 / 16.0);					ImageError[h + 1][w][0] += tempError0 * (5 / 16.0);					ImageError[h + 1][w][1] += tempError1 * (5 / 16.0);					ImageError[h + 1][w][2] += tempError2 * (5 / 16.0);					ImageError[h + 1][w + 1][0] += tempError0 * (3 / 16.0);					ImageError[h + 1][w + 1][1] += tempError1 * (3 / 16.0);					ImageError[h + 1][w + 1][2] += tempError2 * (3 / 16.0);					ImageError[h + 1][w - 1][0] += tempError0 * (1 / 16.0);					ImageError[h + 1][w - 1][1] += tempError1 * (1 / 16.0);					ImageError[h + 1][w - 1][2] += tempError2 * (1 / 16.0);				}			}		}	}	//--------------------------save Error diffuesed image to File--------------------------------------	if (!(file = fopen(argv[2], "wb"))) {		cout << "Cannot open file: " << argv[2] << endl;		exit(1);	}	fwrite(OutputMBVQ, sizeof(unsigned char), SIZE, file);	fclose(file);	return 0;}