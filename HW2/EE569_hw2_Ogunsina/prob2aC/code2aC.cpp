//  EE569 Homework Assignment # 2 Prob 2a, C : Dithering Matrix //  Name:   Morayo Abisola Ogunsina//  ID:     7371213793//  Date:   02/23/2021//  email:  ogunsina@usc.edu // To run the code : // 1. Use terminal and navigate to code path = /prob2aC // 2. type in g++ -o prob2aC code2aC.cpp // 3. then prob2aC.exe <input_raw>  // e.g prob2aC.exe bridge.raw  // to view output on ImageJ: // 1. import raw output file // 2. select image type 8-bit RGB // 3. set width to 332, height to 501 // 4. OK.#include <string.h>#include <stdio.h>#include <iostream>#include <stdlib.h>using namespace std; /* Write Raw funtion: writes the processed image data, saves into a .raw file for viewing*/void writeRaw(void* outputdata, const int length, const char* filename) {	FILE* file;	// Write image data (filename specified by second argument) from image data matrix	if (!(file = fopen(filename, "wb"))) {		cout << "Cannot open file: " << filename << endl;		exit(1);	}	fwrite(outputdata, sizeof(unsigned char), length, file); // mult by 3 for rgb color	fclose(file);}int main(int argc, char* argv[]){	///////////////////////// BEGINNING CODE PROVIDED BY TA, ADDED MODIFICATIONS /////////////////////////	// Define file pointer and variables	FILE* file;	//---------------------------------Get aruguments------------------------------------------   	const int ImgWidth = 332;   // number of columns in the image,	const int ImgHeight = 501;  // number of rows in the image	const int SIZE = ImgHeight * ImgWidth;  	//----------------variables	unsigned char Imagedata [ImgHeight][ImgWidth];            // input image	//--------------------for stroting the imagefile names----------------------------------//	const char* I2file = "I2Img.raw";	const char* I8file = "I8Img.raw";	const char* I32file = "I32Img.raw";			//--------------------------read image----------------------------	if (!(file = fopen(argv[1], "rb"))) {		cout << "Cannot open file: " << argv[1] << endl;		exit(1);	}	fread(Imagedata, sizeof(unsigned char), SIZE, file);	fclose(file);	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////	//--------------------- Specify parameters for Dithering Matrix-------------------------	/* Dithering Matrix logic as specified by Bayer,	*      [1  2]	       [3  0]		   where 0 = most likely pixel to be switched on and 3 least likely	*/	// create the matrices and initialize them	int I2[2][2] = { {1,2},{3,0} }; // This is I2	int I4[4][4];  // need this for recursive generation of I8	int I8[8][8];	int I16[16][16]; // and this for I32	int I32[32][32];	// apply the Bayer's logic to create the dithering matrices	//I4 : need this to create I8 matrix	for (int i = 0; i < 4; i++) {		for (int j = 0; j < 4; j++) {			int temp = 4 * I2[i % (4 / 2)][j % (4 / 2)];			if (i < (4 / 2) && j < (4 / 2))				I4[i][j] = temp + 1;			else if (i < (4 / 2) && j >= (4 / 2))				I4[i][j] = temp + 2;			else if (i >= (4 / 2) && j < (4 / 2))				I4[i][j] = temp + 3;			else if (i >= (4 / 2) && j >= (4 / 2))				I4[i][j] = temp + 0;		}	}	// I8	for (int i = 0; i < 8; i++)	{		for (int j = 0; j < 8; j++)		{			int temp = 4 * I4[i % (8 / 2)][j % (8 / 2)];			if (i < (8 / 2) && j < (8 / 2))				I8[i][j] = temp + 1;			else if (i < (8 / 2) && j >= (8 / 2))				I8[i][j] = temp + 2;			else if (i >= (8 / 2) && j < (8 / 2))				I8[i][j] = temp + 3;			else if (i >= (8 / 2) && j >= (8 / 2))				I8[i][j] = temp + 0;		}	}	// I16 : need this to create I32 matrix	for (int i = 0; i < 16; i++)	{		for (int j = 0; j < 16; j++)		{			int temp = 4 * I8[i % (16 / 2)][j % (16 / 2)];			if (i < (16 / 2) && j < (16 / 2))				I16[i][j] = temp + 1;			else if (i < (16 / 2) && j >= (16 / 2))				I16[i][j] = temp + 2;			else if (i >= (16 / 2) && j < (16 / 2))				I16[i][j] = temp + 3;			else if (i >= (16 / 2) && j >= (16 / 2))				I16[i][j] = temp + 0;		}	}	// I32	for (int i = 0; i < 32; i++)	{		for (int j = 0; j < 32; j++)		{			int temp = 4 * I16[i % (32 / 2)][j % (32 / 2)];			if (i < (32 / 2) && j < (32 / 2))				I32[i][j] = temp + 1;			else if (i < (32 / 2) && j >= (32 / 2))				I32[i][j] = temp + 2;			else if (i >= (32 / 2) && j < (32 / 2))				I32[i][j] = temp + 3;			else if (i >= (32 / 2) && j >= (32 / 2))				I32[i][j] = temp;		}	}	//--------------------- Generate the Dithering Threshold Matrix here-------------------------	int I2thresholdVal[2][2];	int I8thresholdVal[8][8];	int I32thresholdVal[32][32];	// for I2	for (int i = 0; i < 2; i++) {		for (int j = 0; j < 2; j++) {			I2thresholdVal[i][j] = ((I2[i][j] + 0.5) / (2 * 2)) * 255;		}	}	// for I8	for (int i = 0; i < 8; i++) {		for (int j = 0; j < 8; j++) {			I8thresholdVal[i][j] = ((I8[i][j] + 0.5) / (8 * 8)) * 255;		}	}	// for I32	for (int i = 0; i < 32; i++) {		for (int j = 0; j < 32; j++) {			I32thresholdVal[i][j] = ((I32[i][j] + 0.5) / (32 * 32)) * 255;		}	}	//--------------------- Output memory for Half Toned Image data-------------------------	unsigned char I2tempOutput[ImgHeight][ImgWidth];	unsigned char I8tempOutput[ImgHeight][ImgWidth];	unsigned char I32tempOutput[ImgHeight][ImgWidth];	//--------------------- Apply Dithering Matrix Trheshold here-------------------------	//      Transform the dithering matrix into a threshold matrix T, then apply the below logic	//               0   if F(i,j) <= T(i mod N, j mod N)	// G(i,j) =     255  if otherwise			for (int h = 0; h < ImgHeight; h++) {		for (int w = 0; w < ImgWidth; w++) {			int pixel = (int)Imagedata[h][w];			// for I2			if (pixel <= I8thresholdVal[h % 2][w % 2])				I2tempOutput[h][w] = 0;			else if (pixel > I8thresholdVal[h % 2][w % 2])				I2tempOutput[h][w] = 255;			// for I8			if (pixel <= I8thresholdVal[h % 8][w % 8])				I8tempOutput[h][w] = 0;			else if (pixel > I8thresholdVal[h % 8][w % 8])				I8tempOutput[h][w] = 255;			// for I32			if (pixel <= I32thresholdVal[h % 32][w % 32])				I32tempOutput[h][w] = 0;			else if (pixel > I32thresholdVal[h % 32][w % 32])				I32tempOutput[h][w] = 255;		}	}	//--------------------------save Dithered image to File--------------------------------------	writeRaw(I2tempOutput, ImgHeight* ImgWidth * 1, I2file);	writeRaw(I8tempOutput, ImgHeight* ImgWidth * 1, I8file);	writeRaw(I32tempOutput, ImgHeight* ImgWidth * 1, I32file);			return 0;}