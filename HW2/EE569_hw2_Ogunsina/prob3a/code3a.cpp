//  EE569 Homework Assignment # 2 Prob 3a :  : Separable Error Diff for Color Images //  Date:   02/07/2021//  Name:   Morayo Abisola Ogunsina//  ID:     7371213793//  email:  ogunsina@usc.edu // To run the code : // 1. Use terminal and navigate to code path = /prob3a // 2. type in g++ -o prob3a code3a.cpp // 3. then prob3a.exe <input_raw> <image width> <image height> <color mode>  // e.g prob3a.exe fish.raw 640 426 3 // to view output on ImageJ: // 1. import raw output file // 2. select image type 24-bit RGB // 3. set width to 640, height to 426 // 4. OK.#include <string.h>#include <stdio.h>#include <iostream>#include <stdlib.h>using namespace std;/* Write Raw funtion: writes the processed image data, saves into a .raw file for viewing*/void writeRaw(void* outputdata, const int length, const char* filename) {	FILE* file;	// Write image data (filename specified by second argument) from image data matrix	if (!(file = fopen(filename, "wb"))) {		cout << "Cannot open file: " << filename << endl;		exit(1);	}	fwrite(outputdata, sizeof(unsigned char), length, file); // mult by 3 for rgb color	fclose(file);}// combine the channels // check here for input namesunsigned char*** combineChannels(unsigned char*** input3D, unsigned char** ch1, unsigned char** ch2, unsigned char** ch3, int height, int width, int BytesPerPixel) {	input3D = new unsigned char** [height];	for (int i = 0; i < height; i++) {		input3D[i] = new unsigned char* [width];		for (int j = 0; j < width; j++) {			input3D[i][j] = new unsigned char[BytesPerPixel]();			input3D[i][j][0] = ch1[i][j];  // R			input3D[i][j][1] = ch2[i][j];  // G			input3D[i][j][2] = ch3[i][j];  // B		}	}	return input3D;}// separate the channels // check here for input namesunsigned char** seperateChannels(unsigned char*** combinedImage, unsigned char** separatedImage, int height, int width, int channelNumber) {	separatedImage = new unsigned char* [height];	for (int i = 0; i < height; i++) {		separatedImage[i] = new unsigned char[width];		for (int j = 0; j < width; j++) {			separatedImage[i][j] = 255 - combinedImage[i][j][channelNumber];		}	}	return separatedImage;}int main(int argc, char* argv[]){	///////////////////////// BEGINNING CODE PROVIDED BY TA, ADDED MODIFICATIONS /////////////////////////	// Define file pointer and variables	FILE* file;	//---------------------------------Get aruguments------------------------------------------   	int ImgWidth = atoi(argv[2]);            // number of columns in the image,	int ImgHeight = atoi(argv[3]);           // number of rows in the image	int BytesPerPixel = atoi(argv[4]);       // color type 1, grayscale, 3 RGB 	const int SIZE = ImgHeight * ImgWidth * BytesPerPixel;	    //----------------variables	unsigned char* Imagedata = new unsigned char[SIZE]();         // input image	unsigned char* OuputdataSED = new unsigned char[SIZE]();        // output, seperable error diffusion	//--------------------------read image----------------------------	if (!(file = fopen(argv[1], "rb"))) {		cout << "Cannot open file: " << argv[1] << endl;		exit(1);	}	fread(Imagedata, sizeof(unsigned char), SIZE, file);	fclose(file);	//--------------------for stroting the imagefile names----------------------------------//	const char* FSfile = "I2Img.raw";	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////	///////////////////////// MEMORY ALLOCATION FOR VARIABLES /////////////////////////	// transform 1d image data to 3D array --------	unsigned char*** imageData3D = NULL;	long int count = 0;	imageData3D = new unsigned char** [ImgHeight]();	for (int i = 0; i < ImgHeight; i++) {		imageData3D[i] = new unsigned char* [ImgWidth];		for (int j = 0; j < ImgWidth; j++) {			imageData3D[i][j] = new unsigned char[BytesPerPixel]();			for (int k = 0; k < BytesPerPixel; k++) {				imageData3D[i][j][k] = Imagedata[count];				count++;			}		}	}	//--------------------- temp memory for extraction of each color CMY channels-------------------------	unsigned char** imageDataChannelCyan = NULL;	imageDataChannelCyan = seperateChannels(imageData3D, imageDataChannelCyan, ImgHeight, ImgWidth, 0);	unsigned char** imageDataChannelMangenta = NULL;	imageDataChannelMangenta = seperateChannels(imageData3D, imageDataChannelMangenta, ImgHeight, ImgWidth, 1);	unsigned char** imageDataChannelYellow = NULL;	imageDataChannelYellow = seperateChannels(imageData3D, imageDataChannelYellow, ImgHeight, ImgWidth, 2);	//--------------------- temp memory to normalize the CMY color channels-------------------------	long double** ErrorCyan = new long double* [ImgHeight];	long double** ErrorMangenta = new long double* [ImgHeight];	long double** ErrorYellow = new long double* [ImgHeight];	for (int i = 0; i < ImgHeight; ++i) {		ErrorCyan[i] = new long double [ImgWidth];		ErrorMangenta[i] = new long double[ImgWidth];		ErrorYellow[i] = new long double [ImgWidth];		for (int j = 0; j < ImgWidth; j++) {			ErrorCyan[i][j] = 1 - (float)imageDataChannelCyan[i][j] / 255;			ErrorMangenta[i][j] = 1 - (float)imageDataChannelMangenta[i][j] / 255;			ErrorYellow[i][j] = 1 - (float)imageDataChannelYellow[i][j] / 255;		}	}	//--------------------- construct 2d heap memory to hold temp channels-------	unsigned char** outputCyan = new unsigned char* [ImgHeight];	unsigned char** outputMangenta = new unsigned char* [ImgHeight];	unsigned char** outputYellow = new unsigned char* [ImgHeight];	for (int i = 0; i < ImgHeight; ++i) {		outputCyan[i] = new unsigned char[ImgWidth];		outputMangenta[i] = new unsigned char[ImgWidth];		outputYellow[i] = new unsigned char[ImgWidth];	}	//--------------------- construct 3d heap output memory for combined values-------	unsigned char*** outputCombined = new unsigned char** [ImgHeight];	for (int i = 0; i < ImgHeight; ++i) {		outputCombined[i] = new unsigned char* [ImgWidth];				for (int j = 0; j < ImgWidth; j++) {			outputCombined[i][j] = new unsigned char[BytesPerPixel];		}	}	//-------------------- apply the Floyd-Steinberg error diffusion matrix---------------------//	//                     for digital half-toning for each color channel	/*                     3 x 3 matrix: I3/16						   0 0 0						   0 0 7						   3 5 1	*/                   	// error variables	double tempErrorCyan = 0;	double tempErrorMangenta = 0;	double tempErrorYellow = 0;	for (int h = 0; h < ImgHeight; h++) {		// do left to right scanning aka even indexed-scanning		if (h % 2 == 0) {			for (int w = 0; w < ImgWidth; w++) {				// FOR CYAN				if (ErrorCyan[h][w] <= 0.5)				{					// get error difference					tempErrorCyan = ErrorCyan[h][w] - 0;					outputCyan[h][w] = (unsigned char)255;				}				else				{					tempErrorCyan = ErrorCyan[h][w] - 1;					outputCyan[h][w] = (unsigned char)0;				}				// FOR MANGENTA				if (ErrorMangenta[h][w] <= 0.5)				{					// get error difference					tempErrorMangenta = ErrorMangenta[h][w] - 0;					outputMangenta[h][w] = (unsigned char)255;				}				else				{					tempErrorMangenta = ErrorMangenta[h][w] - 1;					outputMangenta[h][w] = (unsigned char)0;				}				// FOR YELLOW				if (ErrorYellow[h][w] <= 0.5)				{					// get error difference					tempErrorYellow = ErrorYellow[h][w] - 0;					outputYellow[h][w] = (unsigned char)255;				}				else				{					tempErrorYellow = ErrorYellow[h][w] - 1;					outputYellow[h][w] = (unsigned char)0;				}				// now do the serpentine scanning				if (w + 1 < ImgWidth) {					ErrorCyan[h][w + 1] += tempErrorCyan * 7 / 16;					ErrorMangenta[h][w + 1] += tempErrorMangenta * 7 / 16;					ErrorYellow[h][w + 1] += tempErrorYellow * 7 / 16;				}				if (w > 0 && h + 1 < ImgHeight) {					ErrorCyan[h + 1][w - 1] += tempErrorCyan * 3 / 16;					ErrorMangenta[h + 1][w - 1] += tempErrorMangenta * 3 / 16;					ErrorYellow[h + 1][w - 1] += tempErrorYellow * 3 / 16;				}				if (h + 1 < ImgHeight) {					ErrorCyan[h + 1][w] += tempErrorCyan * 5 / 16;					ErrorMangenta[h + 1][w] += tempErrorMangenta * 5 / 16;					ErrorYellow[h + 1][w] += tempErrorYellow * 5 / 16;				}				if (h + 1 < ImgHeight && w + 1 < ImgWidth) {					ErrorCyan[h + 1][w + 1] += tempErrorCyan * 1 / 16;					ErrorMangenta[h + 1][w + 1] += tempErrorMangenta * 1 / 16;					ErrorYellow[h + 1][w + 1] += tempErrorYellow * 1 / 16;				}			}		}		// do right to left scanning aka odd indexed-scanning		if (h % 2 != 0) {			for (int w = 0; w < ImgWidth; w++) {				// FOR CYAN				if (ErrorCyan[h][w] <= 0.5)				{					// get error difference					tempErrorCyan = ErrorCyan[h][w] - 0;					outputCyan[h][w] = (unsigned char)255;				}				else				{					tempErrorCyan = ErrorCyan[h][w] - 1;					outputCyan[h][w] = (unsigned char)0;				}				// FOR MANGENTA				if (ErrorMangenta[h][w] <= 0.5)				{					// get error difference					tempErrorMangenta = ErrorMangenta[h][w] - 0;					outputMangenta[h][w] = (unsigned char)255;				}				else				{					tempErrorMangenta = ErrorMangenta[h][w] - 1;					outputMangenta[h][w] = (unsigned char)0;				}				// FOR YELLOW				if (ErrorYellow[h][w] <= 0.5)				{					// get error difference					tempErrorYellow = ErrorYellow[h][w] - 0;					outputYellow[h][w] = (unsigned char)255;				}				else				{					tempErrorYellow = ErrorYellow[h][w] - 1;					outputYellow[h][w] = (unsigned char)0;				}				// now do the serpentine scanning				if (w + 1 < ImgWidth) {					ErrorCyan[h][w + 1] += tempErrorCyan * 7 / 16;					ErrorMangenta[h][w + 1] += tempErrorMangenta * 7 / 16;					ErrorYellow[h][w + 1] += tempErrorYellow * 7 / 16;				}				if (w > 0 && h + 1 < ImgHeight) {					ErrorCyan[h + 1][w - 1] += tempErrorCyan * 3 / 16;					ErrorMangenta[h + 1][w - 1] += tempErrorMangenta * 3 / 16;					ErrorYellow[h + 1][w - 1] += tempErrorYellow * 3 / 16;				}				if (h + 1 < ImgHeight) {					ErrorCyan[h + 1][w] += tempErrorCyan * 5 / 16;					ErrorMangenta[h + 1][w] += tempErrorMangenta * 5 / 16;					ErrorYellow[h + 1][w] += tempErrorYellow * 5 / 16;				}				if (h + 1 < ImgHeight && w + 1 < ImgWidth) {					ErrorCyan[h + 1][w + 1] += tempErrorCyan * 1 / 16;					ErrorMangenta[h + 1][w + 1] += tempErrorMangenta * 1 / 16;					ErrorYellow[h + 1][w + 1] += tempErrorCyan * 1 / 16;				}			}		}	}	//--------------------------- Join all the the CMY channels together------------------------------//	outputCombined = combineChannels(outputCombined, outputCyan, outputMangenta, outputYellow, ImgHeight, ImgWidth, BytesPerPixel);		//-------------------- Change back to RGB, almost forgot this step, lol.---------------------//	for (int i = 0; i < ImgHeight; i++) {		for (int j = 0; j < ImgWidth; j++) {			outputCombined[i][j][0] = 255 - outputCombined[i][j][0];			outputCombined[i][j][1] = 255 - outputCombined[i][j][1];			outputCombined[i][j][2] = 255 - outputCombined[i][j][2];		}	}	//--------------------------convert back to 1d --------------------------------------	// https://stackoverflow.com/questions/3902648/c-representing-a-3d-array-in-a-1d-array	for (int i = 0; i < ImgHeight; i++) {		for (int j = 0; j < ImgWidth; j++) {			for (int k = 0; k < BytesPerPixel; k++) {				OuputdataSED[(i * ImgWidth + j) * 3 + k] = outputCombined[i][j][k];							}		}	}	//--------------------------save Error diffuesed image to File--------------------------------------	writeRaw(OuputdataSED, SIZE, FSfile);  // forgot to multiply by 3, kept getting half image		delete[] Imagedata;	delete[] OuputdataSED;		return 0;}