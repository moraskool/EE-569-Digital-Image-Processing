//  EE569 Homework Assignment 2 #Prob1a//  Date:   02/07/2021//  Name:   Morayo Abisola Ogunsina//  ID:     7371213793//  email:  ogunsina@usc.edu // PLEASE VIEW README.txt file for extensive instructions#include <stdio.h>#include <iostream>#include <stdlib.h>#include <vector>#include <fstream>#include <math.h>using namespace std;/* Write Raw funtion: writes the processed image data, saves into a .raw file for viewing*/void writeRaw(void* outputdata, const int length, const char* filename) {	FILE* file;	// Write image data (filename specified by second argument) from image data matrix	if (!(file = fopen(filename, "wb"))) {		cout << "Cannot open file: " << filename << endl;		exit(1);	}	fwrite(outputdata, sizeof(unsigned char), length, file); // mult by 3 for rgb color	fclose(file);}int main(int argc, char* argv[]){	///////////////////////// BEGINNING CODE PROVIDED BY TA, ADDED MODIFICATIONS /////////////////////////	// Define file pointer and variables	FILE* file;	// DEFAULT IS SET FOR ELEPHANT.RAW	  //const int ImgWidth = 481;                  // number of columns in the image,	  //const int ImgHeight = 321;                 // number of rows in the image	// UNCOMMENT THIS LINE FOR SKI-PERSON.RAW	const int ImgWidth = 321;                 // number of columns in the image,	const int ImgHeight = 481;                // number of rows in the image	int BytesPerPixel = atoi(argv[2]);         // color type 1, grayscale, 3 RGB	float percentThreshold = atof(argv[3]);    // threshold percentage	// get size of image length	int length = BytesPerPixel * ImgHeight * ImgWidth;	//----------------arrays---------------------------------//	unsigned char Imagedata[ImgHeight][ImgWidth][3];          // input image	unsigned char GrayOutput[ImgHeight][ImgWidth][1];         // output to store grayscale image	//--------------------for stroting the imagefile names----------------------------------//	const char* gxfile = "XgradientImg.raw";	const char* gyfile = "YgradientImg.raw";	const char* grayscaleFile = "GrayScaleImg.raw";	const char* magnitudeImge = "GradientMagnitudeImg.raw";	const char* threshImage = "ThresholdImg.raw";	// Read image (filename specified by first argument) into image data matrix	if (!(file = fopen(argv[1], "rb"))) {		cout << "Cannot open file: " << argv[1] << endl;		exit(1);	}	fread(Imagedata, sizeof(unsigned char), ImgHeight * ImgWidth * 3, file);	fclose(file);	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////	//--------------------- array memory for gradient values-------------------------//	float GXGradient[ImgHeight][ImgWidth][1];	float GYGradient[ImgHeight][ImgWidth][1];	float magnitude[ImgHeight][ImgWidth][1];	//--------------------- array memory for normalized gradient values-------------------------//	unsigned char normalizedGx[ImgHeight][ImgWidth][1];         // output, normalized horizontal gradient	unsigned char normalizedGy[ImgHeight][ImgWidth][1];         // output normalized vertical gradient	unsigned char normalizedMag[ImgHeight][ImgWidth][1];        // output of final edge map	//------------------ convert rom RGB to Grayscale using formula in handout -------------------------------//	for (unsigned int h = 0; h < ImgHeight; h++) {		for (unsigned int w = 0; w < ImgWidth; w++) {			int Red = (int)Imagedata[h][w][0];			int Green = (int)Imagedata[h][w][1];			int Blue = (int)Imagedata[h][w][2];			float Gray = 0.2989 * Red + 0.5870 * Green + 0.1140 * Blue;   // change the var			GrayOutput[h][w][0] = (unsigned char)Gray;		}	}	//----------------------Find the gradients----------------------------------------------//	int GXmask[3][3] = { {-1,0,1}, {-2,0,2}, {-1,0,1} };  // x-direction mask/filter/kernel	int GYmask[3][3] = { {1,2,1},{0,0,0},{-1,-2,-1} };    // y-direction mask/filter/kernel	// get the Gx and Gy	for (unsigned int h = 1; h < ImgHeight - 1; h++) {		for (unsigned int w = 1; w < ImgWidth - 1; w++) {			float xgradientValue = 0;			float ygradientValue = 0;			for (int i = -1; i <= 1; i++) {				for (int j = -1; j <= 1; j++) {					int pixel = (int)GrayOutput[h + i][w + j][0];					xgradientValue += pixel * GXmask[i + 1][j + 1];					ygradientValue += pixel * GYmask[i + 1][j + 1];				}			}			GXGradient[h][w][0] = xgradientValue;  // Get the X gradient, Gx			GYGradient[h][w][0] = ygradientValue;  // Get the Y gradient, Gy		}	}	// get the magnitude, G	for (unsigned int h = 1; h < ImgHeight - 1; h++) {		for (unsigned int w = 1; w < ImgWidth - 1; w++) {			magnitude[h][w][0] = sqrt(GXGradient[h][w][0] * GXGradient[h][w][0] + GYGradient[h][w][0] * GYGradient[h][w][0]);		}	}	//--------------------------Normalize the gradient values on the 0-255 scale--------------------------------//	// get min and max pixel values for both x and y gradients and magnitude	float xMax = 5, xMin = 5;	float yMax = 5, yMin = 5;	float gMax = 5, gMin = 5;	for (unsigned int h = 1; h < ImgHeight - 1; h++) {		for (unsigned w = 0; w < ImgWidth - 1; w++) {			float xPixel = GXGradient[h][w][0];			float yPixel = GYGradient[h][w][0];			float gradPixel = magnitude[h][w][0];			// for x			if (xPixel < xMin)				xMin = xPixel;			else if (xPixel > xMax)				xMax = xPixel;			// for y			if (yPixel < yMin)				yMin = yPixel;			else if (yPixel > yMax)				yMax = yPixel;			// for magnitude			if (gradPixel < gMin)				gMin = gradPixel;			else if (gradPixel > gMax)				gMax = gradPixel;		}	}	// then normalize based on those values	for (unsigned int row = 1; row < ImgHeight - 1; row++) {		for (unsigned int col = 1; col < ImgWidth - 1; col++) {			float x = GXGradient[row][col][0];			float y = GXGradient[row][col][0];			float grad = magnitude[row][col][0];			normalizedGx[row][col][0] = (unsigned char)(((x - xMin) / (xMax - xMin)) * 255);			normalizedGy[row][col][0] = (unsigned char)(((y - yMin) / (yMax - yMin)) * 255);			normalizedMag[row][col][0] = (unsigned char)(((grad - gMin) / (gMax - gMin)) * 255);		}	}	//---------------------------- Find the final image edge map here -------------------------------------------------//  // get the frequency of the intensities of the gradient magnitude  // reuse code from homework 1 prob 1b here	int intensityValMagHist[256] = { 0 };	float cHist[256];	for (int h = 1; h < ImgHeight - 1; h++) {		for (int w = 1; w < ImgWidth - 1; w++) {			intensityValMagHist[normalizedMag[h][w][0]] += 1;		}	}	// then get the cummulative histogram 	cHist[0] = intensityValMagHist[0];	for (int i = 1; i < 256; i++) {		cHist[i] = cHist[i - 1] + intensityValMagHist[i];	}	for (int i = 0; i < 256; i++) {		cHist[i] /= (float)cHist[255];  // can merge this ? need double or float?	}	int threshold;	for (int p = 0; p < 256; p++) {		// set threshold as cHist value larger or equal to threshold band		if (cHist[p] >= percentThreshold) {			threshold = p;			break;		}	}	//----------------------------Then Apply the threshold here -------------------------------------------------//	unsigned char ThreshOutput[ImgHeight][ImgWidth][1];   // output threshold-ed   // get the thresholded image pixel values 	for (int h = 1; h < ImgHeight - 1; h++) {		for (int w = 1; w < ImgWidth - 1; w++) {			int pixel = (int)normalizedMag[h][w][0];			// only get pixels that meet the threshold value defined by the percentage			if (pixel < threshold)				ThreshOutput[h][w][0] = 255;			else if (pixel >= threshold)				ThreshOutput[h][w][0] = 0;		}	}	//--------------------------Write histogram of normalized gradient magnitude-----------------------------	ofstream file1;	file1.open("histogramGradMag.txt", ios::out);	for (int i = 0; i < 256; i++)	{		file1 << i << " \t  " << intensityValMagHist[i] << endl;	}	file1.close();	//--------------------------Write cummulative histogram of intensity val after thresholding-----------------------------	ofstream file2;	file1.open("histogramCummulative.txt", ios::out);	for (int i = 0; i < 256; i++)	{		file1 << i << " \t  " << cHist[i] << endl;	}	file1.close();	//------------------ save processed images to file  --------------------------------------------------------//	writeRaw(normalizedGx, ImgHeight * ImgWidth * 1, gxfile);           // x gradient map	writeRaw(normalizedGy, ImgHeight * ImgWidth * 1, gyfile);          // y gradient map	writeRaw(GrayOutput, ImgHeight * ImgWidth * 1, grayscaleFile);       // grayscale image	writeRaw(normalizedMag, ImgHeight * ImgWidth * 1, magnitudeImge);  // gradient magnitude map	writeRaw(ThreshOutput, ImgHeight * ImgWidth * 1, threshImage);   // threshold / edge map	return 0;}