//  EE569 Homework Assignment #Prob 2b p//  Date:   02/07/2021//  Name:   Morayo Abisola Ogunsina//  ID:     7371213793//  email:  ogunsina@usc.edu // To run the code ://1. Use terminal and navigate to code path = / prob2b//2. type in g++ - o prob2b code2b.cpp//3. then type in prob2b.exe <noisy_input_raw> <original_grey_input_raw> <output_raw> <window size> <SigmaCValue> < SigmaSValue>//4. e.g prob2b.exe Fruits_gray_noisy.raw Fruits_gray.raw Fruits_bilinear_5_10_10.raw 5 10 10 // to view output on ImageJ: // 1. import raw output file // 2. select image type 24-bit RGB // 3. set width to 500, height to 400 // 4. OK.#include <iostream>#include <iomanip>#include <math.h>#include <string.h>#include <stdio.h>#include <iostream>#include <stdlib.h>using namespace std;// control how the sliding window moves over the entire image space// also account for boundry probleminline int padding(const int size, int index) {	if (index >= size) {		return 2 * size - index - 2;	}	else if (index < 0) {		return -index;	}	else {		return index;	}}// convolution here for sliding window. Had to use a template here due to c++ constraints (too much work) template<typename T>inline float convolve(T* data, const int dataHeight, const int dataWidth, const int row, const int col, float* filter, const int filterHeight) {	int horiShift = filterHeight / 2;	int vertShift = filterHeight / 2;	float sum = 0;	float weightSum = 0;	for (int i = 0; i < filterHeight; i++) {		for (int j = 0; j < filterHeight; j++) {			float w = filter[filterHeight * i + j];			T d = data[(dataWidth * padding(dataHeight, row + i - vertShift) + padding(dataWidth, col + j - horiShift))];			sum += w * d;		}	}	return sum;}void SlidingWindowBilateral(float* filter, const int filterHeight, const float sigmaC, const float sigmaS, unsigned char* data, const int dataHeight, const int dataWidth, const int row, const int col) {	// get dist between neighbouring pixels and pixels with noise	int filterHoriMid = filterHeight / 2;	int filterVertMid = filterHeight / 2;	for (int i = 0; i < filterHeight; i++) {		for (int j = 0; j < filterHeight; j++) {			int vertDist = i - filterVertMid;			int horiDist = j - filterHoriMid;			float pixelDistSqr = 0;			// get index of sliding window in relation to neighboring pixels			int y = dataWidth * padding(dataHeight, i - filterVertMid + i) + padding(dataWidth, j - filterHoriMid + j);			int k = dataWidth * padding(dataHeight, i) + padding(dataWidth, j);			int chDist = data[y] - data[k];			pixelDistSqr += chDist * chDist; // square the distance			filter[filterHeight * i + j] = exp(-((vertDist * vertDist + horiDist * horiDist) / (2.0 * pow(sigmaC, 2))) - (pixelDistSqr / (2.0 * pow(sigmaS, 2)))); // x * x for integer, pow(x, 2) for float		}	}	//---------------------------- then normalize it---------------------------------------------	float sum = 0;     // window sum	for (int i = 0; i < filterHeight * filterHeight; i++) {		sum += filter[i];  // cummulative addition	}	for (int i = 0; i < filterHeight * filterHeight; i++) {		filter[i] /= sum;  // normalization	}	}/// Calculate PSNR(dB)float getPSNR(unsigned char* noiseFree, unsigned char* filtered, const int size) {	float mse = 0;	// calculate the difference squared	for (int i = 0; i < size; i++) {		int diff = filtered[i] - noiseFree[i];		mse += diff * diff;	}	// normalize it based on data size (from formula)	mse /= size;	return 10 * log10(255 * 255 / mse); // just return a number, no need to create a new variable}int main(int argc, char* argv[]) {	///////////////////////// BEGINNING CODE PROVIDED BY TA, ADDED MODIFICATIONS /////////////////////////	FILE* file;	// Define file pointer and variables	int BytesPerPixel = 1;	const int ImgWidth = 500, ImgHeight = 400; // number of columns in the image, // number of rows in the image	const int SIZE = ImgWidth * ImgHeight;	//---------------------------------Get aruguments------------------------------------------	int windowSize = atoi(argv[4]);     // mask height size	float SigmaC = atoi(argv[5]);       // get SigmaS for Bilateral	float SigmaS = atoi(argv[6]);       // get SigmaS for Bilateral	//----------------variables	unsigned char Imagedata[ImgHeight][ImgWidth];           // noised image	unsigned char noNoiseData[ImgHeight][ImgWidth];         // noiseless image	unsigned char OutBilateral[ImgHeight][ImgWidth];        // filtered image	float* mask = new float[windowSize * windowSize];       // window/mask  size, basically NxN filter 3, 5, 9, 11, etc	//--------------------------read image----------------------------	if (!(file = fopen(argv[1], "rb"))) {		cout << "Cannot open file: " << argv[1] << endl;		exit(1);	}	fread(Imagedata, sizeof(unsigned char), SIZE, file);	fclose(file);	if (!(file = fopen(argv[2], "rb"))) {		cout << "Cannot open file: " << argv[2] << endl;		exit(1);	}	fread(noNoiseData, sizeof(unsigned char), SIZE, file);	fclose(file);	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////   // Non-linear filtering : Bilateral filtering    //-------------------------------------------------------------------------------------------------//   //-------------Apply a filter of size NxN to the noisy image-------------------------------         	for (int h = 0; h < ImgWidth; h++) {		for (int w = 0; w < ImgWidth; w++) {			SlidingWindowBilateral(mask, windowSize, SigmaC, SigmaS, (unsigned char*)Imagedata, ImgHeight, ImgWidth, h, w);			//---------------------------- then normalize it---------------------------------------------			float sum = 0;     // window sum			for (int i = 0; i < windowSize * windowSize; i++) {				sum += mask[i];  // cummulative addition			}			for (int i = 0; i < windowSize * windowSize; i++) {				mask[i] /= sum;  // normalization			}			// Filtered image out			OutBilateral[h][w] = convolve((unsigned char*)Imagedata, ImgHeight, ImgWidth, h, w, mask, windowSize);		}	}	//--------------------Print the mask/filter--------------------------------------------------	// gets computationally intensive at large values	// print the NxN filter/sliding window	/*cout << setprecision(4) << "{" << endl;	for (int i = 0; i < windowSize; i++) {		cout << "\t{";		for (int j = 0; j < windowSize; j++) {			cout << mask[windowSize * i + j] << "|";		}		cout << "}," << endl;	}	cout << endl << "}" << endl << showpoint;*/	delete[] mask;  // memory 	// ------------Calculate the PSNR in decibels --------------------------------------------------------	unsigned int mse1, mse2 = 0;    // mean square error	float psnr1, psnr2;             // peak to signal noise value	// normalize the mse and calculate psnr in decibels	psnr1 = getPSNR((unsigned char*)noNoiseData, (unsigned char*)Imagedata, SIZE);	// calculate MSE for denoised image	psnr2 = getPSNR((unsigned char*)noNoiseData, (unsigned char*)OutBilateral, SIZE);	cout << "PSNR for Noise Image =" << setprecision(5) << psnr1 << showpoint << "dB" << endl;	cout << "PSNR for filtered Image =" << setprecision(5) << psnr2 << showpoint << "dB" << endl;	//--------------------------save denoised image to File--------------------------------------	// Write image data (filename specified by second argument) from image data matrix	if (!(file = fopen(argv[3], "wb"))) {		cout << "Cannot open file: " << argv[3] << endl;		exit(1);	}	fwrite(OutBilateral, sizeof(unsigned char), SIZE, file);	fclose(file);}