//  EE569 Homework Assignment #Prob 2a part 2//  Date:   02/07/2021//  Name:   Morayo Abisola Ogunsina//  ID:     7371213793//  email:  ogunsina@usc.edu// To run the code ://1. Use terminal and navigate to code path = / prob2aB//2. type in g++ - o prob2aB code2a_gaussian.cpp//3. then type in prob2aB.exe <noisy_input_raw> <original_grey_input_raw> <output_raw> < window size> <SigmaC>//4. e.g prob2aB.exe Fruits_grey_noisy.raw Fruits_grey.raw output.raw 3 1.0 // to view output on ImageJ: // 1. import raw output file // 2. select image type 8-bit // 3. set width to 500, height to 400 // 4. OK.#include <iostream>#include <iomanip>#include <math.h>#include <string.h>#include <stdio.h>#include <iostream>#include <stdlib.h>using namespace std;// control how the sliding window moves over the entire image spaceinline int padding(const int size, int index) {	if (index >= size) {		return 2 * size - index - 2;	}	else if (index < 0) {		return -index;	}	else {		return index;	}}// convolution here for sliding window. Had to use a template here due to c++ constraints (too much work) template<typename T>inline float convolve(T* data, const int dataHeight, const int dataWidth, const int row, const int col, float* filter, const int filterHeight) {	int horiShift = filterHeight / 2;	int vertShift = filterHeight / 2;	float sum = 0;	float weightSum = 0;	for (int i = 0; i < filterHeight; i++) {		for (int j = 0; j < filterHeight; j++) {			float w = filter[filterHeight * i + j];			T d = data[(dataWidth * padding(dataHeight, row + i - vertShift) + padding(dataWidth, col + j - horiShift))];			sum += w * d;		}	}	return sum;}/// Apply given filter to all the pixelsvoid SlidingFunction(unsigned char* input, unsigned char* output, const int dataHeight, const int dataWidth, float* filter, const int windowSize) {	for (int h = 0; h < dataHeight; h++) {		for (int w = 0; w < dataWidth; w++) {			// get the index to assign the pixel weight from the mean of each window			int y = 1 * (dataWidth * padding(dataHeight, h) + padding(dataWidth, w));			output[y] = convolve(input, dataHeight, dataWidth, h, w, filter, windowSize);		}	}}/// Calculate PSNR = metric for evaluating performancefloat getPSNR(unsigned char* noiseFree, unsigned char* filtered, const int size) {	float mse = 0;	// calculate the difference squared	for (int i = 0; i < size; i++) {		int diff = filtered[i] - noiseFree[i];		mse += diff * diff;	}	// normalize it based on data size (from formula)	mse /= size;	return 10 * log10(255 * 255 / mse);}int main(int argc, char* argv[]) {	///////////////////////// BEGINNING CODE PROVIDED BY TA, ADDED MODIFICATIONS /////////////////////////	FILE* file;	// Define file pointer and variables	int BytesPerPixel = 1;	const int ImgWidth = 500, ImgHeight = 400; // number of columns in the image, // number of rows in the image	const int SIZE = ImgWidth * ImgHeight;	//---------------------------------Get aruguments------------------------------------------	int windowSize = atoi(argv[4]);     // mask height size	float Sigma = atoi(argv[4]);        // get sigma for gaussian	//----------------variables	unsigned char Imagedata[ImgHeight][ImgWidth];           // noised image	unsigned char noNoiseData[ImgHeight][ImgWidth];         // noiseless image	unsigned char OutputUniformWeight[ImgHeight][ImgWidth]; // filtered image	float* mask = new float[windowSize * windowSize];        // window/mask  size, basically NxN filter 3, 5, 9, 11, etc	//--------------------------read image----------------------------	if (!(file = fopen(argv[1], "rb"))) {		cout << "Cannot open file: " << argv[1] << endl;		exit(1);	}	fread(Imagedata, sizeof(unsigned char), SIZE, file);	fclose(file);	if (!(file = fopen(argv[2], "rb"))) {		cout << "Cannot open file: " << argv[2] << endl;		exit(1);	}	fread(noNoiseData, sizeof(unsigned char), SIZE, file);	fclose(file);	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////	// Linear filtering : Mean filtering and Least Mean Square filtering 	// mean filter = simple sliding window/ mask , (vary the filter sizes)	// Using Linear filtering, use uniform weight funciton (box filter) and gaussaian weight function	// http://www.librow.com/articles/article-5	//-------------------------------------------------------------------------------------------------//	//---------------Generate filter/mask-------------------------------------------------	// set all to 1s // change this later		for (int i = 0; i < windowSize; i++) {		for (int j = 0; j < windowSize; j++) {			int vDist = i - windowSize / 2;			int hDist = j - windowSize / 2;			// from gaussian weights formula in lecture note			mask[windowSize * i + j] = ((1.0) / ((2 * 3.14 * pow(Sigma, 2))))* exp(-((pow(Sigma, 2) + pow(Sigma, 2)) / (2 * pow(Sigma, 2))));		}	}	//---------------------------- then normalize it---------------------------------------------	float sum = 0;     // window sum	for (int i = 0; i < windowSize * windowSize; i++) {		sum += mask[i];  // cummulative addition	}	for (int i = 0; i < windowSize * windowSize; i++) {		mask[i] /= sum;  // normalization	}	//--------------------Print the mask/filter--------------------------------------------------	// print the NxN filter/sliding window	cout << setprecision(4) << "{" << endl;	for (int i = 0; i < windowSize; i++) {		cout << "\t{";		for (int j = 0; j < windowSize; j++) {			cout << mask[windowSize * i + j] << "|";		}		cout << "}," << endl;	}	cout << endl << "}" << endl << showpoint;	//-------------Apply a filter of size NxN to the noisy image-------------------------------	SlidingFunction((unsigned char*)Imagedata, (unsigned char*)OutputUniformWeight, ImgHeight, ImgWidth, mask, windowSize);	delete[] mask;  // memory 	// ------------Calculate the PSNR in decibels --------------------------------------------------------	unsigned int mse1, mse2 = 0;    // mean square error	float psnr1, psnr2;             // peak to signal noise value	// normalize the mse and calculate psnr in decibels	psnr1 = getPSNR((unsigned char*)noNoiseData, (unsigned char*)Imagedata, SIZE);	// calculate MSE for denoised image	psnr2 = getPSNR((unsigned char*)noNoiseData, (unsigned char*)OutputUniformWeight, SIZE);	cout << "PSNR for Noise Image =" << psnr1 << showpoint << "dB" << endl;	cout << "PSNR for filtered Image ="  << psnr2 << showpoint << "dB" << endl;	//--------------------------save denoised image to File--------------------------------------	// Write image data (filename specified by second argument) from image data matrix	if (!(file = fopen(argv[3], "wb"))) {		cout << "Cannot open file: " << argv[3] << endl;		exit(1);	}	fwrite(OutputUniformWeight, sizeof(unsigned char), SIZE, file);	fclose(file);}