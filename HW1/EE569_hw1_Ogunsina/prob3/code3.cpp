//  EE569 Homework Assignment #Prob 2b //  Date:   02/07/2021//  Name:   Morayo Abisola Ogunsina//  ID:     7371213793//  email:  ogunsina@usc.edu // To run the code : // 1. Use terminal and navigate to code path = /prob3 // 2. type in g++ -o prob2b code2b.cpp // 3. then prob3.exe <colored_input_raw> <colored_output_quantized> <colored_output_oileffect> <image width> <image height> <color mode> <number of colors to quantize to> <N> // e.g prob3.exe Fruits.raw Fruits_quant.raw Fruits_oil.raw 64 7 // to view output on ImageJ: // 1. import raw output file // 2. select image type 24-bit RGB // 3. set width to 500, height to 400 // 4. OK.#include <iostream>#include <iomanip>#include <math.h>#include <string.h>#include <stdio.h>#include <iostream>#include <stdlib.h>using namespace std; // combine the channels // check here for input namesunsigned char*** combineChannels(unsigned char*** input3D, unsigned char** ch1, unsigned char** ch2, unsigned char** ch3, int height, int width, int BytesPerPixel) {		input3D = new unsigned char** [height];	for (int i = 0; i < height; i++) {		input3D[i] = new unsigned char* [width];		for (int j = 0; j < width; j++) {			input3D[i][j] = new unsigned char[BytesPerPixel]();			input3D[i][j][0] = ch1[i][j];  // R			input3D[i][j][1] = ch2[i][j];  // G			input3D[i][j][2] = ch3[i][j];  // B		}	}	return input3D;}// separate the channels // check here for input namesunsigned char** seperateChannels(unsigned char*** combinedImage, unsigned char** separatedImage, int height, int width, int channelNumber) {		separatedImage = new unsigned char* [height];		for (int i = 0; i < height; i++) {		separatedImage[i] = new unsigned char[width];		for (int j = 0; j < width; j++) {			separatedImage[i][j] = combinedImage[i][j][channelNumber];		}	}	return separatedImage;}//-----------------------------------------------------------------------------------/*                        QUANTIZATION HERE                                        *//*                use bucket filling method here                                  */unsigned char** Quantize(unsigned char** InputToQuantize, unsigned char** quantizedOutput, int h, int w, int qLevels) {		unsigned int* hIdx = new unsigned int[h*w]();       // to track the height index	unsigned int* wIdx = new unsigned int[h*w]();       // to track the width index	unsigned char* pxlIdx = new unsigned char[h*w]();   // for the pixels	//---------------------------------------------------------	// get the pixels that are of the same colors	// Histogram here	unsigned int tmp = 0;	for (int p = 0; p < 256; p++) {		for (int i = 0; i < h; i++) {			for (int j = 0; j < w; j++) {				if (InputToQuantize[i][j] == p) {					hIdx[tmp] = i;					wIdx[tmp] = j;					pxlIdx[tmp] = p;					tmp = tmp + 1;				}			}		}	}	//----------Putting inside bins-------------------------------------------------	// use weighted mean to get the mean for each of the bins	unsigned int sizeOfBin = floor((float)(h * w) / ((float)qLevels));	for (unsigned int level = 0; level < (h * w); level = level + sizeOfBin) {		float tempSum = 0.0;		unsigned int tempCount = 0;		for (int i = level; i < level + sizeOfBin; i++) {			tempSum = tempSum + pxlIdx[i];			tempCount = tempCount + 1;		}		unsigned int meanOfBin = ceil(tempSum / (float)(tempCount));  // mean value of every bin here		for (int i = level; i < level + sizeOfBin; i++) {			pxlIdx[i] = (unsigned char)meanOfBin;                     // assign back to all pixels in bin		}	}	//----------------Transform pixels back from 1D storage to 2D storage ----------------------	unsigned int tempRowIndex;	unsigned int tempColIndex;	for (int i = 0; i < (h * w); i++) {		tempRowIndex = hIdx[i];		tempColIndex = wIdx[i];		quantizedOutput[tempRowIndex][tempColIndex] = pxlIdx[i]; // from 1d to 2d here	}	//---------------end quantization here-----------------------------------------	return quantizedOutput;}//-----------------------------------------------------------------------------------/*                        SPECIAL EFFECT HERE                                      *//*                Vary N here for differet levels of the special effect.            */unsigned char** SpecialEffect(unsigned char** inputSpecialEffect, unsigned char** input, int height, int width, int N) {	// from gaussian formula a bit	signed int NStart = -floor(N / 2.0);	signed int NEnd = floor(N / 2.0);	// scan the N*N neighbor space, get the frequency of pixels	for (int i = 0; i < height; i++) {		for (int j = 0; j < width; j++) {			unsigned char* pxlCount = new unsigned char[256]();			for (signed int p = NStart; p <= NEnd; p++) {				for (signed int q = NStart; q <= NEnd; q++) {					signed int hIdx = i + p;					signed int wIdx = j + q;					// to check pixels in neigbourhood					if (hIdx < 0) {						hIdx = 0;					}					if (wIdx < 0) {						wIdx = 0;					}					if (hIdx > height - 1) {						hIdx = height - 1;					}					if (wIdx > width - 1) {						wIdx = width - 1;					}					unsigned char tmpIdx = input[hIdx][wIdx];					pxlCount[tmpIdx] ++;				}			}			// select most frequent color in NXN neighbourood 			unsigned char mxCount = pxlCount[0];			int tempMaxPixel = 0;			for (int k = 1; k < 256; k++) {				if (mxCount < pxlCount[k]) {					mxCount = pxlCount[k];					tempMaxPixel = k;				}			}			delete[] pxlCount;  // for memory			inputSpecialEffect[i][j] = tempMaxPixel;		}	}	return inputSpecialEffect;}int main(int argc, char* argv[]){	///////////////////////// BEGINNING CODE PROVIDED BY TA, ADDED MODIFICATIONS /////////////////////////	// Define file pointer and variables	FILE* file;	//int BytesPerPixel = 3;	//const int ImgWidth = 500, ImgHeight = 400;      // number of columns in the image, // number of rows in the image		//---------------------------------Get aruguments------------------------------------------   	int ImgWidth = atoi(argv[4]);            // number of columns in the image,	int ImgHeight = atoi(argv[5]);           // number of rows in the image	int BytesPerPixel = atoi(argv[6]);       // color type 1, grayscale, 3 RGB 	int NumOfQuantLevel = atoi(argv[7]);      // quantization level/ number of colors	int N = atoi(argv[8]);                    // number of levels	const int SIZE = ImgHeight * ImgWidth * BytesPerPixel;  	// Quantization for every Channel	//----------------variables	unsigned char* Imagedata = new unsigned char[SIZE]();                  // input image	unsigned char* OuputdataQuantized = new unsigned char[SIZE];           // output, quantized	unsigned char* OutputdataSpecialEffect = new unsigned char[SIZE];      // output, special effecT	//--------------------------read image----------------------------	if (!(file = fopen(argv[1], "rb"))) {		cout << "Cannot open file: " << argv[1] << endl;		exit(1);	}	fread(Imagedata, sizeof(unsigned char), SIZE, file);	fclose(file);	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////	///////////////////////// MEMORY ALLOCATION FOR VARIABLES /////////////////////////	// transform 1d image data to 3D array --------	unsigned char*** imageData3D = new unsigned char** [ImgHeight];	long int count = 0;	for (int i = 0; i < ImgHeight; i++) {		imageData3D[i] = new unsigned char* [ImgWidth];		for (int j = 0; j < ImgWidth; j++) {			imageData3D[i][j] = new unsigned char[BytesPerPixel]();			for (int k = 0; k < BytesPerPixel; k++) {				imageData3D[i][j][k] = Imagedata[count];				count++;			}		}	}	//--------------------- temp memory for extraction of each color channels-------------------------	unsigned char** imageDataChannelRed = NULL;	imageDataChannelRed = seperateChannels(imageData3D, imageDataChannelRed, ImgHeight, ImgWidth, 0);	unsigned char** imageDataChannelGreen = NULL;	imageDataChannelGreen = seperateChannels(imageData3D, imageDataChannelGreen, ImgHeight, ImgWidth, 1);	unsigned char** imageDataChannelBlue = NULL;	imageDataChannelBlue = seperateChannels(imageData3D, imageDataChannelBlue, ImgHeight, ImgWidth, 2);	//--------------------- temp memory for quantization of all RGB color channels-------------------------   // Allocate memory for 2D array calculations and traversal --------   // source :    // https://www.tutorialspoint.com/How-do-I-declare-a-two-dimensional-array-in-Cplusplus-using-new    // need to create memory for image data calultions using heap.. visual studio was sugesting this and giving errors.   // had to switch to this method	//--------------------- temp memory for Quantization of all RGB color channels-------------------------	unsigned char** input2DRQtized = new unsigned char* [ImgHeight];	unsigned char** input2DGQtized = new unsigned char* [ImgHeight];	unsigned char** input2DBQtized = new unsigned char* [ImgHeight];	//--------------------- temp memory for special effect of all RGB color channels-------------------------	unsigned char** output2DRSpecialEffect = new unsigned char* [ImgHeight];	unsigned char** output2DGSpecialEffect = new unsigned char* [ImgHeight];	unsigned char** output2DBSpecialEffect = new unsigned char* [ImgHeight];	for (int i = 0; i < ImgHeight; ++i) {		input2DRQtized[i] = new unsigned char[ImgWidth];		input2DGQtized[i] = new unsigned char[ImgWidth];		input2DBQtized[i] = new unsigned char[ImgWidth];		output2DRSpecialEffect[i] = new unsigned char[ImgWidth];		output2DGSpecialEffect[i] = new unsigned char[ImgWidth];		output2DBSpecialEffect[i] = new unsigned char[ImgWidth];	}	//--------------------- construct 3d heap output memory, quantization and special effets-------	unsigned char*** output3DQuantized = new unsigned char** [ImgHeight];	unsigned char*** output3DSpecialEffect = new unsigned char** [ImgHeight];	for (int i = 0; i < ImgHeight; ++i) {		output3DQuantized[i] = new unsigned char*[ImgWidth];		output3DSpecialEffect[i] = new unsigned char*[ImgWidth];		for (int j = 0; j < ImgWidth; j++) {			output3DQuantized[i][j] = new unsigned char[BytesPerPixel];			output3DSpecialEffect[i][j] = new unsigned char[BytesPerPixel];		}	}	// Quantization for every Channel	float NumOfQuantLevel_ = pow(NumOfQuantLevel, (1.0 / ((float)(BytesPerPixel))));  // change from 256 to BytesPerPix	// First, separate the colors into the main color channels	// I thought to quantize the whole image as it is, but decided to do it separatly for each channel	// since it is a colored image. Makes sense and suggested in Discussion 2&3 	//-----------Then Quantize next------------------------------------------------------------	input2DRQtized = Quantize(imageDataChannelRed, input2DRQtized, ImgHeight, ImgWidth, NumOfQuantLevel_);	input2DGQtized = Quantize(imageDataChannelGreen, input2DGQtized, ImgHeight, ImgWidth, NumOfQuantLevel_);	input2DBQtized = Quantize(imageDataChannelBlue, input2DBQtized, ImgHeight, ImgWidth, NumOfQuantLevel_);	// Join all the image files together	output3DQuantized = combineChannels(output3DQuantized, input2DRQtized, input2DGQtized, input2DBQtized, ImgHeight, ImgWidth, BytesPerPixel);	//-----------Then apply Special effect-------------------------------------------------------	output2DRSpecialEffect = SpecialEffect(output2DRSpecialEffect, input2DRQtized, ImgHeight, ImgWidth, N);	output2DGSpecialEffect = SpecialEffect(output2DGSpecialEffect, input2DGQtized, ImgHeight, ImgWidth, N);	output2DBSpecialEffect = SpecialEffect(output2DBSpecialEffect, input2DBQtized, ImgHeight, ImgWidth, N);	// Join all the the special effect channels together	output3DSpecialEffect = combineChannels(output3DSpecialEffect, output2DRSpecialEffect, output2DGSpecialEffect, output2DBSpecialEffect, ImgHeight, ImgWidth, BytesPerPixel);	//--------------------------convert back to 1d --------------------------------------	// https://stackoverflow.com/questions/3902648/c-representing-a-3d-array-in-a-1d-array	for (int i = 0; i < ImgHeight; i++) {		for (int j = 0; j < ImgWidth; j++) {			for (int k = 0; k < BytesPerPixel; k++) {				OuputdataQuantized[(i * ImgWidth + j) * 3 + k] = output3DQuantized[i][j][k];				OutputdataSpecialEffect[(i * ImgWidth + j) * 3 + k ] = output3DSpecialEffect[i][j][k];			}		}	}	//--------------------------save Quantized image to File--------------------------------------	if (!(file = fopen(argv[2], "wb"))) {		cout << "Cannot open file: " << argv[3] << endl;		exit(1);	}	fwrite(OuputdataQuantized, sizeof(unsigned char), SIZE, file);	fclose(file);	//--------------------------save SpecialEffect image to File--------------------------------------	if (!(file = fopen(argv[3], "wb"))) {		cout << "Cannot open file: " << argv[3] << endl;		exit(1);	}	fwrite(OutputdataSpecialEffect, sizeof(unsigned char), SIZE, file);	fclose(file);	delete[] Imagedata;	delete[] OuputdataQuantized;	delete[] OutputdataSpecialEffect;	return 0;}