//  EE569 Homework Assignment 3 #Prob1 : Geometric Image Modification //  Date:   03/12/2021//  Name:   Morayo Abisola Ogunsina//  ID:     7371213793//  email:  ogunsina@usc.edu // To run the code : // 1. Use terminal and navigate to code path = /prob2 // 2. type in g++ -o prob2 code2.cpp // 3. then prob3.exe <colored_input_raw> <colored_output_disc> <colored_output_reconstructed> <image width> <image height> <color mode> // e.g prob2.exe Dog.raw DogDisc.raw DogRecon.raw 329 329 3 // to view output on ImageJ: // 1. import raw output file // 2. select image type 24-bit RGB // 3. set width to 329, height to 329 // 4. OK.#include <stdio.h>#include <iostream>#include <stdlib.h>#include <vector>#include <fstream>#include <math.h>using namespace std;/* Write Raw funtion: writes the processed image data, saves into a .raw file for viewing*/void writeRaw(void* outputdata, const int length, const char* filename) {	FILE* file;	// Write image data (filename specified by second argument) from image data matrix	if (!(file = fopen(filename, "wb"))) {		cout << "Cannot open file: " << filename << endl;		exit(1);	}	fwrite(outputdata, sizeof(unsigned char), length, file); // mult by 3 for rgb color	fclose(file);}int main(int argc, char* argv[]){	///////////////////////// BEGINNING CODE PROVIDED BY TA, ADDED MODIFICATIONS /////////////////////////	// Define file pointer and variables	FILE* file;	int ImgWidth = atoi(argv[4]);            // number of columns in the image,	int ImgHeight = atoi(argv[5]);           // number of rows in the image	int BytesPerPixel = atoi(argv[6]);       // color type 1, grayscale, 3 RGB	// get size of image	const int SIZE = ImgHeight * ImgWidth * BytesPerPixel;	//----------------arrays---------------------------------//	unsigned char* Imagedata = new unsigned char[SIZE]();              //  left 	unsigned char* warpedImage = new unsigned char[SIZE]();            //  middle	unsigned char* reconstructedImage = new unsigned char[SIZE]();     //  right	unsigned char* OuputdataWarped = new unsigned char[SIZE];          // warped output	unsigned char* OutputdataRecon = new unsigned char[SIZE];          // reconstructed output		// Read image (filename specified by first argument) into image data matrix	if (!(file = fopen(argv[1], "rb"))) {		cout << "Cannot open file: " << argv[1] << endl;		exit(1);	}	fread(Imagedata, sizeof(unsigned char), ImgHeight * ImgWidth * 3, file);	fclose(file);	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////	//---------------------  transform 1d image data to 3D array --------//	unsigned char*** imageData3D = NULL;	long int count = 0;	imageData3D = new unsigned char** [ImgHeight]();	for (int i = 0; i < ImgHeight; i++) {		imageData3D[i] = new unsigned char* [ImgWidth];		for (int j = 0; j < ImgWidth; j++) {			imageData3D[i][j] = new unsigned char[BytesPerPixel]();			for (int k = 0; k < BytesPerPixel; k++) {				imageData3D[i][j][k] = Imagedata[count];				count++;			}		}	}	//--------------------- construct 3d heap ouput-------	unsigned char*** imageDisc3D = new unsigned char** [ImgHeight+50];	unsigned char*** imageRecon3D = new unsigned char** [ImgHeight+50];	for (int i = 0; i < ImgHeight +50; ++i) {		imageDisc3D[i] = new unsigned char* [ImgWidth];		imageRecon3D[i] = new unsigned char* [ImgWidth];		for (int j = 0; j < ImgWidth; j++) {			imageDisc3D[i][j] = new unsigned char[BytesPerPixel];			imageRecon3D[i][j] = new unsigned char[BytesPerPixel];		}	}	////---------------------------- Do the mapping here-------------------------------------------------//	// I was able to figure out how to make the mapping but cannot figure out how to make it larger as done	// in the handout. Maybe I'm missing something?		for (int i = 0; i < ImgHeight; i++) {			for (int j = 0; j < ImgWidth ; j++) {				// NORMALIZE AND GET CENTER POINTS				long double x = (i - ((ImgHeight / 2) - 1)) / (long double)((ImgHeight / 2) - 1);				long double y = (j - ((ImgWidth / 2) - 1)) / (long double)((ImgWidth / 2) - 1);				// DEFINE THE IMAGE COORDINATES				long double u = x * sqrt(1 - ((pow(y, 2))) / 2);				long double v = y * sqrt(1 - ((pow(x, 2))) / 2);				// DEFINE POLAR COORDINATES				unsigned int p = (u * ((ImgHeight / 2) - 1)) + ((ImgHeight / 2) - 1);				unsigned int q = (v * ((ImgWidth / 2) - 1)) + ((ImgWidth / 2) - 1);				// MAP NEW IMAGE TO DISC				imageDisc3D[p][q][0] = imageData3D[i][j][0];				imageDisc3D[p][q][1] = imageData3D[i][j][1];				imageDisc3D[p][q][2] = imageData3D[i][j][2];				// INVERSE MAPPING HERE FOR RECONSTRUCTED IMAGE				// disc to square mapping				long double xnew = 1.00 / 2.00 * ((sqrt((2 + (pow(u, 2)) - (pow(v, 2)) + (2 * (sqrt(2) * u))))) - (sqrt((2 + (pow(u, 2)) - (pow(v, 2)) - (2 * (sqrt(2) * u))))));				long double ynew = 1.00 / 2.00 * ((sqrt((2 - (pow(u, 2)) + (pow(v, 2)) + (2 * (sqrt(2) * v))))) - (sqrt((2 - (pow(u, 2)) + (pow(v, 2)) - (2 * (sqrt(2) * v))))));				unsigned int l = round((xnew * (((ImgHeight / 2) - 1))) + ((ImgHeight / 2) - 1));				unsigned int m = round((ynew * (((ImgWidth / 2) - 1))) + ((ImgWidth / 2) - 1));				imageRecon3D[l][m][0] = imageDisc3D[p][q][0];				imageRecon3D[l][m][1] = imageDisc3D[p][q][1];				imageRecon3D[l][m][2] = imageDisc3D[p][q][2];			}		}	//----------------------------convert back to 1d-------------------------------------------------//	// https://stackoverflow.com/questions/3902648/c-representing-a-3d-array-in-a-1d-array		for (int i = 0; i < ImgHeight; i++) {			for (int j = 0; j < ImgWidth ; j++) {				for (int k = 0; k < BytesPerPixel; k++) {					OuputdataWarped[(i * (ImgWidth ) + j) * 3 + k] = imageDisc3D[i][j][k];					OutputdataRecon[(i * (ImgWidth ) + j) * 3 + k] = imageRecon3D[i][j][k];				}			}		}	//------------------ save processed images to file  ---------------------------------------------------------//	writeRaw(OuputdataWarped, (ImgHeight)* (ImgWidth) * 3, argv[2]);       // output, warped image	writeRaw(OutputdataRecon, (ImgHeight) * (ImgWidth) * 3, argv[3]);      // output, reconstructed image	delete[] Imagedata;	delete[] warpedImage;	delete[] reconstructedImage;	return 0;}